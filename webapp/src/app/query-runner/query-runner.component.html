<mat-tab-group
  [(selectedIndex)]="tabIndex"
  class="mat-tab-fill-height full-size"
>
  <mat-tab label="Explanations">
    <div class="tab-content">
      <p>
        SPINDLE enables some statistics on distributed databases without
        revealing any data. It does so by using a new kind of cryptography,
        allowing to apply common mathematical operation on encrypted data and
        only revealing the result.
      </p>
      <p>
        In this demo, we only show a fraction of SPINDLE, namely the training of
        <a href="https://en.wikipedia.org/wiki/Generalized_linear_model"
          >generalized linear models</a
        >. It is a statistical method to predict the outcome of a given row of
        data, based on a known set of representative values, the dataset.
      </p>
      <p>
        The shown tables are a set of several medical metrics, easily
        measurable, and show if the patient has diabetes. Thus we will be able
        to predict if someone is likely diabetic, or not.
        <br />
        Each table is stored on a separated node, nothing is shared in clear,
        yet, by cooperating with each others, the network can deliver the
        results to you.
      </p>
      <p>
        Now, you can move to the next part, where you will train a model using
        SPINDLE.
      </p>
    </div>
  </mat-tab>

  <mat-tab label="Train Model">
    <div fxLayout="row" fxLayoutAlign="center center" class="full-size">
      <div fxFlex="30%">
        <form [formGroup]="trainForm" (ngSubmit)="runTrainRequest()">
          <mat-list>
            <mat-list-item>
              <mat-form-field>
                <mat-label>Learning rate</mat-label>
                <input
                  matInput
                  type="number"
                  min="0.01"
                  max="1"
                  step="0.01"
                  formControlName="learningRate"
                />
              </mat-form-field>
            </mat-list-item>

            <mat-list-item>
              <mat-form-field>
                <mat-label>Elastic rate</mat-label>
                <input
                  matInput
                  type="number"
                  min="0.01"
                  max="1"
                  step="0.01"
                  formControlName="elasticRate"
                />
              </mat-form-field>
            </mat-list-item>

            <mat-list-item>
              <mat-form-field>
                <mat-label>Local iteration count</mat-label>
                <input
                  matInput
                  type="number"
                  min="1"
                  formControlName="localIterationCount"
                />
              </mat-form-field>
            </mat-list-item>

            <mat-list-item>
              <mat-form-field>
                <mat-label>Local batch size</mat-label>
                <input
                  matInput
                  type="number"
                  min="1"
                  formControlName="localBatchSize"
                />
              </mat-form-field>
            </mat-list-item>

            <mat-list-item>
              <mat-form-field>
                <mat-label>Network iteration count (epochs)</mat-label>
                <input
                  matInput
                  type="number"
                  min="1"
                  formControlName="networkIterationCount"
                />
              </mat-form-field>
            </mat-list-item>

            <mat-list-item>
              <button
                mat-raised-button
                color="primary"
                type="submit"
                [disabled]="!trainForm.valid"
              >
                Train
              </button>
            </mat-list-item>
          </mat-list>
        </form>
      </div>
      <div fxFlex="50%">
        <ul>
          <li>
            <b>Learning rate</b>: how much each iteration is to be taken into
            account. The greater, the faster it will obtain a solution but the
            more likely the solution won't be the best one.
          </li>
          <li>
            <b>Elastic rate:</b> how much randomness to add at each local
            iteration, to try to find a better solution that the previous one.
          </li>
          <li>
            <b>Local iteration count</b>: how many times the local model is
            trained before doing a network iteration. The greater, the slower it
            will compute locally but, if the datasets are similar, it would
            require less network iterations.
          </li>
          <li>
            <b>Local batch size</b>: when computing a local iteration, how many
            labelled data samples to train upon at the same time. The greater,
            the more precise the solution will be but the more memory it will
            take.
          </li>
          <li>
            <b>Network iteration count</b>: how many times is the model on the
            whole network trained, that is computing an aggregatation of each
            local model, and used this to feed the next local iterations.
          </li>
        </ul>
      </div>
    </div>
  </mat-tab>

  <mat-tab label="Predict with a Model">
    <div fxLayout="column" class="tab-content">
      <div *ngIf="state[0] === 'training'" class="result-line">
        Training model...
      </div>

      <div
        *ngIf="state[0] === 'training' || state[0] === 'train error'"
        class="result-line"
      >
        <ng-container *ngIf="state[0] === 'training'">
          <ng-container *ngIf="state[1] === undefined">
            <div fxLayout>
              Connecting
              <mat-progress-bar mode="buffer"></mat-progress-bar>
            </div>
          </ng-container>
          <ng-container *ngIf="state[1] !== undefined">
            <div fxLayout>
              Local
              <mat-progress-bar
                mode="determinate"
                value="{{ state[1][0] }}"
              ></mat-progress-bar>
            </div>
            <div fxLayout>
              Network
              <mat-progress-bar
                mode="determinate"
                value="{{ state[1][1] }}"
              ></mat-progress-bar>
            </div>
          </ng-container>
        </ng-container>
        <ng-container *ngIf="state[0] === 'train error'">
          Error encountered when training model: {{ state[1].message }}
        </ng-container>
      </div>

      <div
        *ngIf="
          state[0] === 'trained' ||
          state[0] === 'predict error' ||
          state[0] === 'predicted'
        "
      >
        <div class="result-line">Model ID: {{ state[1] }}</div>

        <div class="result-line">
          <form
            [formGroup]="predictForm"
            (ngSubmit)="runPredictRequest()"
            class="result-line"
          >
            <mat-form-field>
              <mat-label>To predict</mat-label>
              <input matInput type="text" formControlName="toPredict" />
            </mat-form-field>

            <button
              mat-raised-button
              color="primary"
              type="submit"
              [disabled]="!predictForm.valid"
            >
              Predict
            </button>
          </form>
        </div>
      </div>

      <div class="result-line">
        <ng-container *ngIf="state[0] === 'predicted'">
          The trained model predicts that the given unlabelled data sample's
          label will be: <b>{{ state[2] }}</b>
        </ng-container>
        <ng-container *ngIf="state[0] === 'predict error'">
          Error encountered when training model: {{ state[2].message }}
        </ng-container>
      </div>
    </div>
  </mat-tab>
</mat-tab-group>
